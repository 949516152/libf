1.python的函数用法

2.函数式接口 是仅包含一个抽象方法的接口；函数式接口通常只表示单个动作；
	lambda表达式只能用于其目标类型已被指定的上下文中；
	
3.lambda表达式是对函数式接口的一种实现

4.lambda表达式可以获取或设置其外层类的实例或静态变量的值，以及调用器外层类定义的方法。
		但是当lambda表达式使用其外层作用域内定义的局部变量时，会产生一种特殊情况，称为变量捕获。

5.lambda表达式可以使用和修改其调用类的实例变量，只是不能使用其外层作用域内的局部变量，除非该变量实质上是final变量

6. lambda表达式与方法引用

	（1）静态方法的方法引用也可以获取函数式接口的实例，例如 ：（类名：：静态方法名） 类名为静态方法所在的类
	（2）实例方法的方法引用也可以获取函数式接口的实例，
			例如 ：（实例对象名：：方法名） 实例对象名为静态方法所在的类的实例
	（3）泛型中的方法引用
	
	
7.lambda表达式与构造函数引用
		语法一般形式为：className::new
		也可以获取函数式接口的实例
		构造函数的参数需与函数式接口的参数相同,
		泛型类创建构造函数引用与一般相同，区别在于可以指定类型参数。
		但 函数式接口的方法返回对象为className对象
		
		
8.JDK 1.7以后整型字面值可嵌入一个或多个下划线，使阅读容易，编译时会自动丢弃。
			下划线只能用于分割数值，不能位于数值的开头和结尾。
			
9.位运算

10.switch 的表达式在JDK 1.7 之前必须是byte，short ，int char 和枚举，在jdk7之后添加了string类型。

11.堆栈！！！！！！！！！！！！！！


12.对this的理解！！！！！！！！！！！！！！！！！！！！！！！！！！！

13.java在运行时动态分析对方法的调用，称为后期绑定；
   因final方法不能被重写，所以final方法的调用可以在编译时解析，称为早期绑定。
   
   
   
   

14.jdk 1.8之前接口方法不能实现，没有方法体；
	jdk1.8之后可以在接口方法中添加默认实现，即默认方法，也称扩展方法，默认方法允许为接口方法定义默认实现，
	 默认方法的声明使用关键字 default
	实现方法的类型签名必须和接口定义中指定的类型签名精确匹配。
	
15.在封装范围之外使用嵌套接口时，必须使用包含嵌套接口的类或或接口的名称进行限定。
		即 嵌套接口的名称必须是完全限定的。

16.接口规则：类实现的优先级高于默认实现；
				当类实现的两个接口都提供了相同的默认方法，但类没有重写改方法，会发生错误。！！
				
				如果一个接口继承了另外一个接口，并且两个接口定义了相同的默认方法，那么继承接口的版本具有更高优先级！！！
				通过super的另一种新的形式，可以显式的引用被继承接口中的默认实现，形式：InterfaceName.super.MethodName();

17.jdk1.8以后接口也可以定义静态方法，
		接口定义的静态方法可以独立于任何对象调用。
		因此，在调用静态方法时，不需要实现接口，也不需要接口的实例。
		形式：InterfaceName.staticMethod
		
		实现接口的类 或 子接口 不会集成接口中的静态方法。
		
18，异常

1.带资源的try 自动资源管理

2.所有异常类型都是throwable的子类。又分为 Exception和Error;没有被程序捕获的异常都会被系统默认的处理程序处理
3.自行捕获的有点：1）允许修复错误，2）阻止程序自动终止

4.链式异常  明天查看
5.jdk7新特性，带资源的try；多重捕获，使用或运算符（|）；


19，多线程

1.多任务处理，分为  1）基于进程的多任务处理，程序是调度程序能够调度的最小代码单元
					2）基于线程的多任务处理，线程是最小的可调度的代码单元
	（抢占式多任务处理）
2.java增加了Fork/Join框架