java并发编程
1.java编程的并发级别：
1）阻塞
2）无饥饿
3）无障碍
4）无锁
5）无等待


java 同步中的有四种锁：

synchronized：同步锁（悲观锁）性能稳定适用于大部分场景
ReentrantLock:可重入锁
ReentrantReadWriteLock:可重入读写锁（悲观锁）
stampedLock:戳锁 当并发量大且读远大于写的情况下最快的的是StampedLock锁



高并发场景下的三种处理方式：缓存、限流、降级。缓存的目的是提升系统访问速度和增大系统能处理的容量，可谓是抗高并发流量的银弹；而降级是当服务出问题或者影响到核心流程的性能则需要暂时屏蔽掉，待高峰或者问题解决后再打开；而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页），因此需有一种手段来限制这些场景的并发/请求量，即限流。

限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务（定向到错误页或告知资源没有了）、排队或等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据，如商品详情页库存默认有货）。


一般开发高并发系统常见的限流有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数）、限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。


AQS：
	抽象队列同步器（AbstractQueuedSynchronizedr，简称AQS）:是用来构建锁或者其他同步组件的基础框架，使用整形的volatile变量
	命名为state，来维护同步状态，通过内置的FIFO队列来完成资源获取线程的工作。


