20，枚举  枚举定义了一种类类型，枚举定义了类， 所有枚举继承自Enum
		可以为枚举提供构造函数、添加实例变量或方法，实现接口，
		枚举也可以重载
		
1.创建枚举需要使用关键字 enum;
2.枚举中包含枚举常量，枚举常量被隐式声明为公有的、静态final成员；
		枚举常量的类型是声明他们的枚举的类型；
		枚举常量的使用方式：1,）EnumName.枚举常量，并导入枚举 import enums.DemonEnum;
							2）例如，使用import static enums.DemonEnum.枚举变量，可以直接使用单个枚举常量;

3，枚举常量也被称为“自类型化的”，“自”是指封装常量的枚举。

4，尽管枚举一种类类型，但枚举不能使用new实例化；可创建枚举变量，在声明和使用方面与基本类型类似；
		枚举变量的赋值只能被赋在枚举变量类型下的值。
				枚举常量的使用，可以使用对应的枚举类型对象
		
5，可以使用“==”比较两个枚举常量。
		在switch case中没有使用枚举类型名称对枚举常量进行限定，
		是因为case已经隐式指定了case中枚举常量的枚举类型；
		一旦使用名称进行限定则会造成编译时错误。

6.所有枚举都自动包含两个预定义方法：values()和valueOf();
			values()方法返回一个包含所有枚举常量的数组；
			valueOf()方法返回与传递参数字符串相对应的枚举常量；
			
7，每个枚举常量都是所属枚举类型的对象。
		枚举定义的构造函数，每当创建枚举常量时都会调用构造函数；
		构建 枚举常量 时可以为 枚举构造函数 赋值传参，
		
		当有构造函数情况下，调用枚举常量时，会依次调用n（枚举常量个数）次构造函数
		
		每个枚举常量都是定义它的类的对象
		
		枚举调用方法 是通过枚举常量调用的
		
8,枚举的限制 ：1）枚举不能继承其他类
				2）枚举不能是超类
				
9.指示枚举常量在常量列表中的位置的值，称为枚举常量的序数值。
		通过ordinal()方法来检索序数值；
	使用compareTo()来比较相同类型的枚举常量的序数值，将调用常量和参数常量比较，
	若调用常量的序数值小，返回负数，等于返回0，大于参数常量则返回正数；
	
	使用equals()来比较枚举常量和其他对象的相等性
	可以使用“==”来比较两个枚举引用的相等性