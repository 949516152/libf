21，注解  在源文件中的嵌入补充信息。
1）java注解 是 基于接口的机制创建的。
				所有注解都只包含方法声明，且不能有方法体，并且都不能含参数；
		Annotation是所有注解的超接口
		注解不能包含extends子句。
		注解要放在声明的最前面。
		先声明注解，后使用
2）jdk1.8之前注解只能用于声明
	所有类型的声明都可以有与之关联的注解；
	使用注解时，需要为注解成员提供值；

3）注解的使用
		注解的名称以 @ 为前缀，后面跟位于圆括号中的 成员初始化列表
		初始化成员 提供值，需要为成员的名称赋予值；当为注解成员提供值时，只使用注解成员的名称；
		
		可以为注解成员提供默认值，默认值 是通过 为成员声明添加default子句 指定的，
		一般形式如下：
			type member() default value
		其中value的类型必须与type兼容

4）指定 保留策略
		所谓保留策略，即决定在什么位置丢弃注解。有三种策略，分别为SOURCE，CLASS，RUNTIME；
		一、SOURCE保留策略，只在源文件中保留，编译期间会丢弃；
		二、CLASS保留策略，在编译时被保留在.class文件中，但在运行时通过JVM不会得到这些注解；
		三、RUNTIME保留策略，在编译时被保留在.class文件中，在运行时通过JVM会得到这些注解；
		因此，RUNTIME保留策略提供了最永久的注解。（其中局部变量的注解不能保存在.class文件中）
		
	保留策略是通过java的内置注解--@Retention指定的，它的一般形式为：
		@Retention(retention-policy)
	其中，retention-policy，必须是上面的枚举常量之一，如果没有指定保留策略，则默认为CLASS策略。
	
	当使用 RUNTIME策略 时，可以通过反射来获取注解。
	获取注解，先获取对应的方法或类、成员变量；
		Method f = c.getMethod(方法名[，arg1.class,arg2.class]);
			其中，[]内表示当方法有参数时，必须指定 参数类型的类对象 作为getMethod方法的 参数。
		Demon_2 f= m.getAnnotation(Demon_2.class);此表达式表示Demon_2类型的Class对象，称为“类字面值”。
		
		
5）标记注解 ， 是特殊的注解，不包含成员。
		其唯一目的，就是标注声明。
		      确认标记注解是否存在的最好方式是使用isAnnotationPresent()；该方法是由AnnotateElement接口定义的；
			  
6）单成员注解  只包含一个成员
		允许使用缩写形式指定成员的值，不需使用成员名称‘而为了使用这种缩写，单成员注解的成员名称必须是value！！！
		
	当使用含有其他成员的注解时，也可以使用单值语法，但其他成员必须都有默认值
	
7）内置注解   大部分是专用注解，但有9个用于一般注解

8）类型注解 ?  ?????????????????????????
	类型注解必须使用ElementType.TYPE_USE作为目标
	类型注解需要放到应用该注解的类型的前面；
	
	
9)重复注解   允许相同元素上重复应用注解；
							可重复的注解必须使用@Repeatable进行注解
		要创建重复注解，必须创建容器注解然后将容器注解的类型指定为@Repeatable注解的参数。
		为使getAnnotation()方法访问重复注解，需要使用容器注解，而不是重复注解。
		
		
10）
注解的一些限制：
	一个注解不能继承另一个注解；
	注解声明的所有方法不能带有参数；
	不能返回以下类型的值：
		基本类型；
		String或Class类型的对象；
		枚举类型；
		其他注解类型；
		上述类型的数组；
	注解不能被泛型化；
	注解方法不能指定throws子句。