本包学习代理模式：

代理模式：
    定义：代理模式是给某个对象提供代理对象，并由代理对象控制原对象的引用。

代理模式分为 JDK代理 与 CGLIB代理：
    其中JDK代理依赖于接口，静态代理的代理对象与被代理对象都实现相同的接口，代理类通过组合的方式实现代理；
        其中动态代理代理类实现 InvocationHandler 接口
    而CGLIB代理 则不依赖接口，代理类实现 MethodInterceptor 接口


代理模式分为：动态代理、静态代理
    静态代理：是由程序员或特定的工具生成源代码，再对其进行编译；
    动态代理：是在程序运行时通过反射机制动态创建的。


静态代理
    优点：可以在符合开闭原则下对目标对象进行拓展；
    缺点：需要为每一个服务创建代理类，工作量太大，不易管理。


JDK 动态代理：
    动态代理的实现要实现 InvocationHandler接口，实现invoke方法，同时拓展增加私有化对象属性，添加有参构造方法

    在调用代理类是通过Java的Proxy代理类，调用静态方法newProxyInstance的方法，该方法接口三个参数，
        ClassLoader loader：指定当前目标对象的类加载器，获取类加载器的方法是固定的；
        Class<?> interfaces:指定当前目标对象实现的接口类型，使用泛型方式确定类型；
        InvocationHandler：指定动态处理器，执行目标对象方法时，会触发事件处理器的方法。


    动态代理：减少了开发任务，减少对接口的依赖，降低耦合。

    JDK动态代理需要实现类通过接口定义的业务方法，即JDk动态代理依赖于接口。




CGLIB代理:

    JDK 动态代理要求被代理的类必须实现接口，而CGLIB没有此局限性，即可以不用实现接口；
    CGLIB创建的动态代理对象比JDK创建的动态代理对象性能更高，但是CGLIB创建的代理对象花费的时间更长；

    对于单例因无须频繁创建对象，CGLIB适合，反之JDK代理更加合适.

   CGLIB 代理：
        要实现MethodInterceptor接口，重写intercept方法，通过Enhancer类方法创建对象代理，需强制转换；

        Enhancer类可以为非接口类型创建java代理，Enhancer动态创建了给定类型的子类但是拦截了所有的方法。
        和Proxy不同，不管是接口还是类都能正常工作。

        在intercept方法中可以使用method.invoke(target,args)方式，也可以是methodProxy.invokeSupper(o,args);
            一般推荐使用第二种方式。
            proxy.invokeSuper和proxy.invoke的区别:
                invokeSuper是退出当前interceptor的处理，进入下一个callback处理，
                invoke则会继续回调该方法，如果传递给invoke的obj参数出错容易造成递归调用。

        第一种方式：method.invoke(target,args),第一个参数为代理目标，第二个参数是参数数组。
        第二种方式：methodProxy.invokeSupper(o,args)，第一个参数是形参对象，第二个参数是参数数组。









代理方式
JDK静态代理	实现：代理类与委托类实现同一接口，并且在代理类中需要硬编码接口
            优点：实现简单，容易理解
            缺点：代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低
            特点：无
JDK动态代理	实现：代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理
            优点：不需要硬编码接口，代码复用率高
            缺点：只能够代理实现了接口的委托类
            特点：底层使用反射机制进行方法的调用
CGLIB动态代理	实现：代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，
                        它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，
                        它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理
               优点：可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口
               缺点：不能对final类以及final方法进行代理
               特点：底层将方法全部存入一个数组中，通过数组索引直接进行方法调用
